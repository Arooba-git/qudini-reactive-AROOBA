// Generated by delombok at Wed Feb 02 15:24:58 CET 2022
package com.qudini.reactive.security;

import com.qudini.reactive.logging.Log;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.web.server.ResponseStatusException;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilter;
import org.springframework.web.server.WebFilterChain;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.Collection;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import static java.util.stream.Collectors.toUnmodifiableSet;
import static org.springframework.http.HttpStatus.FORBIDDEN;
import static org.springframework.http.HttpStatus.UNAUTHORIZED;
import static org.springframework.security.core.context.ReactiveSecurityContextHolder.withAuthentication;

public final class AuthenticationFilter implements WebFilter {
    @java.lang.SuppressWarnings("all")
    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(AuthenticationFilter.class);
    private final Collection<? extends AuthenticationService<?>> authenticationServices;

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        return findAuthentication(exchange).defaultIfEmpty(new AnonymousAuthentication()).flatMap(authentication -> filter(exchange, chain, authentication));
    }

    private Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain, Authentication authentication) {
        var loggingContext = Optional.ofNullable(authentication.getName()).map(principal -> Map.of("principal", principal)).orElseGet(Map::of);
        return chain.filter(exchange.mutate().principal(Mono.just(authentication)).build()).onErrorResume(AccessDeniedException.class, e -> ReactiveSecurityContextHolder.getContext().mapNotNull(SecurityContext::getAuthentication).filter(Authentication::isAuthenticated).flatMap(x -> Mono.<Void>error(new ResponseStatusException(FORBIDDEN))).switchIfEmpty(Mono.error(new ResponseStatusException(UNAUTHORIZED)))).contextWrite(withAuthentication(authentication)).contextWrite(Log.addContext(loggingContext));
    }

    private Mono<Authentication> findAuthentication(ServerWebExchange exchange) {
        return Flux.fromIterable(authenticationServices).flatMap(authenticationService -> authenticationService.authenticate(exchange)).collect(toUnmodifiableSet()).flatMap(Log.then(this::chooseAuthentication)).flatMap(Mono::justOrEmpty);
    }

    private Optional<Authentication> chooseAuthentication(Set<? extends Authentication> authentications) {
        var iterator = authentications.iterator();
        if (!iterator.hasNext()) {
            return Optional.empty();
        }
        var authentication = iterator.next();
        if (iterator.hasNext()) {
            log.warn("Unable to authenticate, found {} valid authentications: {}", authentications.size(), authentications);
            return Optional.empty();
        }
        return Optional.of(authentication);
    }

    @java.lang.SuppressWarnings("all")
    public AuthenticationFilter(final Collection<? extends AuthenticationService<?>> authenticationServices) {
        this.authenticationServices = authenticationServices;
    }
}
